# 分布式系统技术概要
## 分布式系统之配置管理
在分布式集群中，如何让每一个节点了解节点的状态、了解其所以来的服务的地址等信息、协调集群间的协作，等等这些事情对于整个集群的正常工作至关重要。所以这便是 Apache Zookeeper 之类的软件的用武之地。

### Apache Zookeeper
Zookeeper 是一个分布式的服务管理框架。Zookeeper 的典型的应用场景包括配置文件的管理、集群管理、分布式锁、Leader 选举、队列管理等。Zookeeper 可工作在集群模式下，`zoo.cfg` 中记录着集群中所有 Zookeeper 服务器的地址，每个服务器有自己唯一的 ID。同时，每个服务器在自己的 `dataDir` 目录下还要有一个 `myid` 文件，以标示自己的 ID。

现在类似 Zookeeper 的项目还有 CoreOS 的 Etcd

### Apache Curator
Zookeeper 的客户端框架，简化 Zookeeper 的使用

## 分布式存储之文件系统
### 块存储与对象存储
块存储是将一块裸盘提供给客户使用，但是这块裸盘可能是来自一块物理硬盘，也有可能是多块，或是来自不同服务器上的硬盘。对象存储提供了更高级的接口，通过这些接口可以读写文件以及相关的元数据。其中的元数据包含了文件每一个块的存储信息。通过文件元数据，文件可以被并行地操作。

### 分布式文件系统的高可用
为了保证数据的安全，分布式文件系统通常会将文件复制为三份。这三份数据会位于不同的服务器上，对应要求更高的系统，比如公有云存储。其中的一份数据会放置在另一个机房中，以保证即便整个机房出现故障，整个文件系统仍是可用的。

### Ceph
Ceph 目前是 OpenStack 的一个组件，提供了块存储和对象存储的功能。

### GridFS
GridFS 是 MongoDB 的一部分。用来存储超过 BSON 大小限制（16MB）的文件。GridFS 将文件分成一个个部分，分开存储。

### FastDFS
FastDFS 是一个轻量的分布式文件系统，适合存储中小文件（对象存储）。FastDFS 的跟踪服务器不负责记录文件的元信息。文件的具体存储位置等信息包含在返回给用户的 File ID 中。

## 分布式存储之内存
> 内存是新的硬盘，硬盘是新的磁带 
> -- Jim Gray

### Hazelcast
Hazelcast 是一个面向 Java 的分布式内存解决方案，提供了丰富的功能特性。实现了诸如分布式 Java 集合类、分布式锁、分布式 ExecutorService 实现等等。但现实往往是残酷的，Hazelcast 在实际应用中存在大量的缺陷。详见 [“hazelcast的坑爹事”](http://blog.csdn.net/hengyunabc/article/details/18514563)

### GridGain

### Memcached
Memcached 是老牌的“分布式”缓存解决方案。分布式之所以加引号，是因为 Memcached 服务器端本身并不支持分布式，服务器端每个节点之间并不会相互通信。分布式的支持需要客户端来实现。早期的内存分布式是通过节点之间复制来实现的，但这种方式却限制了可伸缩性。这也是因为诸如 Terrecotta 这样的内存分布式解决方案没有成为主流的原因。

## 分布式存储之数据库
### 数据库中间件
在互联网大行其道之前，数据库都是单机的，即便支持集群，规模也是有限的，比如 MySQL 的 NDB Cluster 引擎。在互联网规模还不大的时候，数据库（这里往往指 SQL 数据库）自带的集群解决方案，结合读写分离的模式，还是可以满足需要。但是很快随着互联网应用规模的快速增大，短短几年时间，网站的数据库就必须分库分表了。这个时候单单靠数据库本身就没有办法解决集群化之后所产生的问题了。同时，各种 NoSQL 数据库虽然是为了互联网而生，但这并不意味他们天生就支持集群化。例如 Redis 从最近的 3.0 开始才提供了自己的集群方案。

对于大规模的数据库分布式解决方案，单靠数据库本身是不能实现的。必须引入数据访问中间层来解决数据库分布式的问题。在这个领域，各个互联网厂商都有自己的解决方案。这些解决方案，按照使用方式可以分为提供 REST API、编程语言数据库驱动方式（例如 JDBC）、ORM 框架方式、数据库接口协议通信方式。其中最后一种通用性最高，但是开发难度也最大。编程语言数据库驱动的方式对特定的编程语言最好用，但是通用性差。

在这个领域，目前开源的项目不是很多。之前阿里开源的 Cobar 现在已经转为闭源。现在国内开源社区在 [Cobar](http://luruoyu.blog.51cto.com/2876338/929653) 的基础之上发起了一个 MyCAT 的项目，目的是提供一个更好的开源分布式数据库访问中间层。

### NoSQL
首先必须说明的是 NoSQL 并不代表着分布式，所以 NoSQL 

reddis 一致性华西

## 分布式系统之远程调用
分布式系统中，组件的相互调用必须通过远程调用来实现。REST API 和消息队列广义上也算是远程调用，但前者通常用作公开的 API 或者大型服务间的调用。对于服务内部之间的更加细粒度的、频繁的远程调用，REST API 就显得性能不足。这主要是因为协议方面的限制。消息队列则额外地起到了异步和削峰的作用。所以我们这里侧重说一下非 WebService 和消息队列的远程调用。

远程调用的本身有两个重要的技术点，一个是 IO 技术、一个是序列化技术。另外，当组件间的调用变成远程调用之后所引入的服务注册、发现、路由的问题，这个问题可以简称为服务的治理。

远程调用毫无疑问会比本地调用要复杂许多，所以如何提高远程调用的易用性也是在实际开发中使用远程调用是需要考虑的一个重要问题。

### IO
IO 可简单分为阻塞IO与非阻塞IO、同步IO与异步IO 四种模型。阻塞 IO 模型值得是 IO 操作会阻塞发起 IO 的进程或者线程；非阻塞 IO 的一个实现方式 Reactor 模型，即在线程模型上，分出分配 IO 任务的 Boss 线程和执行 IO 操作的 Worker 线程。非阻塞 IO 与 阻塞 IO 相比，进步的地方在于非阻塞 IO 模型中的 Worker 线程在 IO 操作没有 ready 的情况下不会被阻塞。只有当读或写的操作 ready 之后，Worker 线程才会执行任务，而不会无故的阻塞。

异步 IO 则是由操作系统来实现 IO 的读写操作，在数据 ready 之后，交由 Worker 线程来处理。

#### 系统 IO
IO 是一个和操作系统底层联系紧密的技术。对于像 Java 这样的带有虚拟机的语言，会提供一个统一的 IO 抽象。对于 C、C++ 这样的语言，IO 主要就取决于操作系统的支持。

非阻塞 IO 在 Linux 平台上通过 epoll 来支持，在 Windows 平台上通过 iocp 来提供支持。这两者都实现了通过少量的线程而处理多于这个数目的 IO channel 的目的。在 Linux kernel 的 2.6 版本中，引入了对异步 IO 的支持。

#### Java IO
Java 在 1.4 中引入了 NIO 的支持，在 7.0 (1.7) 中引入了 AIO 的支持。通常情况下，Java 开发者不应直接基于 JDK API 开发 IO 的功能，主要是相比操作系统本身提供的 API，JDK 的 API 已经提供了很高层次的抽象，但是对于应用开发来说仍显不足，而且 IO 开发技术要求非常高，需要掌握大量的系统和线程的知识，有大量的错误和特殊情况需要处理。而且 IO 功能通常是整个系统的基础，一旦出错影响将是严重的。所以通常建议开发人员使用 Netty、Mina 等 IO 框架来开发应用。Netty 相较 Mina 来说更多地被使用，Netty 最新版本（5.0）目前是基于 NIO 模型的。在 4.0 的一个早期版本中 Netty 曾使用了 AIO 模型，但是发现缺点大于优点，所以在随后的版本中又去掉了对 AIO 的支持。

### 序列化技术
序列化就是编程语言中的对象与二进制数据之间相互的转换。一个高性能的序列化技术对于一个好的远程调用解决方案来说是必须的。在序列化方面，有名的解决方案包括由 Google 创建的 Protocol Buffers、由 Facebook 创建的、现在由 Apache 社区维护的 Thrift、被 Hadoop 所使用的 Apache Arvo

### 框架介绍
* Apache Thrift
Thrift 是一个高性能、跨语言的 RPC 服务框架，适合用来实现内部服务的 RPC 调用。但是 Thrift 的序列化部分和整个框架结合紧密，并没有直接提供序列化和反序列化的接口，所以不容易和其它传输协议配合使用。

* Protocol Buffers
Protobuf 是一个高性能序列化解决方案，有完善的文档，可以和例如 HTTP 这样的协议搭配使用。

* Apache Avro
Apache Avro 是 Apache Hadoop 的一个子项目。它提供了两种序列化格式：JSON和二进制格式。JSON格式有良好的可读性，而二进制格式在性能上和 Protobuf 不相上下。

### 参考
* [序列化和反序列化](http://www.infoq.com/cn/articles/serialization-and-deserialization)

## 分布式系统之消息中间件
在分布式系统中，消息中间件的重要性越来越明显。消息中间件可以解耦模块、提供异步调用功能、消息持久化、消息削峰。已有的如 Apache ActiveMQ 无法满足新的需要，于是出现了如 RabbitMQ、Apache Kafka 等新型的消息中间件产品。

### Apache Kafka
Apache Kafka 充分利用了机械磁盘顺序读写速度快的特点，在接受消息之后同步地写入到磁盘中，保证数据可靠性的同时，也保证了非常快的速度。每个 Kafka 集群上都有多个 Topic，Topic 相当于一个 category，消费者可以订阅一个或多个 Topic。每个 Topic 由多个 Partition 组成。消息被顺序的添加到 Partition 中，每条消息有一个唯一的、有序的 ID，这个 ID 被称为 Offset。Consumer 需要维护自己消费到的消息的位置 (Offset)。

Apache Kafka 不同于传统的消息中间件，它采用“拉”消息模式，而不是传统的“推”消息模式。即客户端需要主动从消息中间件获取消息，好处是客户端可以更好地控制请求量。

#### Queue 模式和 Topic 模式
传统消息队列服务中有队列模式和发布订阅模式两种模式，前者一条消息只会被一个消费者消费；后者一条消息会发布给所有的订阅这个 Topic 的消费者。在 Kafka 中，这两种模式是使用一种方式 ―― 消费者组来实现的。在同一个消费者组中的不同消费者不会受到相同的消息。如果想实现发布订阅模式，消费者必须处于不同的消费者组中。

### [RabbitMQ](https://www.rabbitmq.com/tutorials/tutorial-one-java.html)
RabbitMQ 是一个使用 Erlang 开发的 AMQP (Advanced Message Queue Protocol) 实现。现在 RabbitMQ 是由 VMware 旗下的 SpringSource 负责开发。AMQP 是一个语言无关的消息队列协议。在 RabbitMQ 中，有三个概念：Exchange、Queue 和 Route key。Exchange 用来标示生产者，Queue 用来标示消费者，而 Route key 用来关联这两者。RabbitMQ 中这种方式提供了更灵活的应用模式。

## 分布式系统之虚拟化技术
虚拟化技术是提高硬件利用率的重要手段。虚拟化技术是实现云计算的重要技术。虚拟化技术的最底层是各种硬件的虚拟化，如 CPU 虚拟化、内存虚拟化、存储虚拟化、网络虚拟化等等。然后再基于这些技术，构建出各种虚拟机技术。然后各个厂商又基于虚拟机技术和其它虚拟化技术构建出 IaaS、PaaS 和 SaaS 等平台和软件产品。

### OpenStack
OpenStack 这个开源项目包含了一系列用于 IaaS 平台搭建的组件的合称。这些组件包含用于网络虚拟化的 Neutron、提供存储虚拟化的 Ceph 和 Swift、以及提供例如镜像管理、控制面板等功能的诸多组件。OpenStack 本身并不提供虚拟化技术，而是通过支持诸多现有的虚拟化技术，例如 KVM，并在此之上提供一系列构建 IaaS 解决方案的技术。OpenStack 中的组件可以灵活搭配使用，并且因为开源的原因，使用者可以对其进行自定义或二次开发。但是也是因为这个原因，任何厂商想要成功使用 OpenStack 必须有一个强大的技术团队做后盾。这也是目前 OpenStack 技术发展遇到的最大困难。

### Docker
严格说来 Docker 并不是一个虚拟化技术，但是因为 Docker 能够提供给使用者一种轻量化的虚拟机的使用体验，所以也将 Docker 列在这里。Docker 是一个容器技术，它通过 Linux 内核的支持，使不同的进程可以相互隔离并做到资源的限制，从而实现了部分的虚拟机资源隔离的需要。Docker 相比较虚拟机的优势在于轻量和系统资源使用效率接近于实体机。因为现在随着需求的发展和技术的进步，服务器端应用向着一种轻量化和越来越分布式的方向发展。虚拟机这样重量级的技术对于小而多的应用来说便不再合适，这也是 Docker 这样的容器技术近些年迅速发展并呈现火热状态的重要原因。

## 高可用系统
### HAProxy
HAProxy 是一个高性能的 TCP 和 HTTP 反向代理代理和负载均衡服务器。可用反向代理和负载均衡还有 Nginx。Niginx 更偏向于 HTTP 协议。另外 Varnish 和 Squid 可以作为前端的代理，但是它们更偏重缓存功能

### Pacemaker & Corosync
基于 Linux 的高可用集群解决方案