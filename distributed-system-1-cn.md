# 分布式系统技术概要
## 分布式系统之网络
### Apache Zookeeper
Zookeeper 是一个分布式的服务管理框架。Zookeeper 的典型的应用场景包括配置文件的管理、集群管理、分布式锁、Leader 选举、队列管理等。Zookeeper 可工作在集群模式下，`zoo.cfg` 中记录着集群中所有 Zookeeper 服务器的地址，每个服务器有自己唯一的 ID。同时，每个服务器在自己的 `dataDir` 目录下还要有一个 `myid` 文件，以标示自己的 ID。

现在类似 Zookeeper 的项目还有 CoreOS 的 Etcd

### Apache Curator
Zookeeper 的客户端框架，简化 Zookeeper 的使用

## 分布式存储之文件系统
### 块存储与对象存储
块存储是将一块裸盘提供给客户使用，但是这块裸盘可能是来自一块物理硬盘，也有可能是多块，或是来自不同服务器上的硬盘。对象存储提供了更高级的接口，通过这些接口可以读写文件以及相关的元数据。其中的元数据包含了文件每一个块的存储信息。通过文件元数据，文件可以被并行地操作。

### 分布式文件系统的高可用
为了保证数据的安全，分布式文件系统通常会将文件复制为三份。这三份数据会位于不同的服务器上，对应要求更高的系统，比如公有云存储。其中的一份数据会放置在另一个机房中，以保证即便整个机房出现故障，整个文件系统仍是可用的。

### Ceph
Ceph 目前是 OpenStack 的一个组件，提供了块存储和对象存储的功能。

### GridFS
GridFS 是 MongoDB 的一部分。用来存储超过 BSON 大小限制（16MB）的文件。GridFS 将文件分成一个个部分，分开存储。

### FastDFS
FastDFS 是一个轻量的分布式文件系统，适合存储中小文件（对象存储）。FastDFS 的跟踪服务器不负责记录文件的元信息。文件的具体存储位置等信息包含在返回给用户的 File ID 中。

## 分布式存储之内存
> 内存是新的硬盘，硬盘是新的磁带 
> -- Jim Gray

### Hazelcast
Hazelcast 是一个面向 Java 的分布式内存解决方案，提供了丰富的功能特性。实现了诸如分布式 Java 集合类、分布式锁、分布式 ExecutorService 实现等等。但现实往往是残酷的，Hazelcast 在实际应用中存在大量的缺陷。详见 [“hazelcast的坑爹事”](http://blog.csdn.net/hengyunabc/article/details/18514563)

### GridGain

### Memcached
Memcached 是老牌的“分布式”缓存解决方案。分布式之所以加引号，是因为 Memcached 服务器端本身并不支持分布式，服务器端每个节点之间并不会相互通信。分布式的支持需要客户端来实现。早期的内存分布式是通过节点之间复制来实现的，但这种方式却限制了可伸缩性。这也是因为诸如 Terrecotta 这样的内存分布式解决方案没有成为主流的原因。

## 分布式存储之数据库
在互联网大行其道之前，数据库都是单机的，即便支持集群，规模也是有限的，比如 MySQL 的 NDB Cluster 引擎。在互联网规模还不大的时候，数据库（这里往往指 SQL 数据库）自带的集群解决方案，结合读写分离的模式，还是可以满足需要。但是很快随着互联网应用规模的快速增大，短短几年时间，网站的数据库就必须分库分表了。这个时候单单靠数据库本身就没有办法解决集群化之后所产生的问题了。同时，各种 NoSQL 数据库虽然是为了互联网而生，但这并不意味他们天生就支持集群化。例如 Redis 从最近的 3.0 开始才提供了自己的集群方案。

对于大规模的数据库分布式解决方案，单靠数据库本身是不能实现的。必须引入数据访问中间层来解决数据库分布式的问题。在这个领域，各个互联网厂商都有自己的解决方案。这些解决方案，按照使用方式可以分为提供 REST API、编程语言数据库驱动方式（例如 JDBC）、ORM 框架方式、数据库接口协议通信方式。其中最后一种通用性最高，但是开发难度也最大。编程语言数据库驱动的方式对特定的编程语言最好用，但是通用性差。

在这个领域，目前开源的项目不是很多。之前阿里开源的 Cobar 现在已经转为闭源。现在国内开源社区在 [Cobar](http://luruoyu.blog.51cto.com/2876338/929653) 的基础之上发起了一个 MyCAT 的项目，目的是提供一个更好的开源分布式数据库访问中间层。

## 分布式系统之远程调用
分布式系统中，组件的相互调用必须通过远程调用来实现。REST API 和消息队列广义上也算是远程调用，但前者通常用作公开的 API 或者大型服务间的调用。对于服务内部之间的更加细粒度的、频繁的远程调用，REST API 就显得性能不足。这主要是因为协议方面的限制。消息队列则额外地起到了异步和削峰的作用。所以我们这里侧重说一下非 WebService 和消息队列的远程调用。

远程调用的本身有两个重要的技术点，一个是 IO 技术、一个是序列化技术。另外，当组件间的调用变成远程调用之后所引入的服务注册、发现、路由的问题，这个问题可以简称为服务的治理。

### IO
IO 可简单分为阻塞IO与非阻塞IO、同步IO与异步IO 四种模型。阻塞 IO 模型值得是 IO 操作会阻塞发起 IO 的进程或者线程；非阻塞 IO 的一个实现方式 Reactor 模型，即在线程模型上，分出分配 IO 任务的 Boss 线程和执行 IO 操作的 Worker 线程。非阻塞 IO 与 阻塞 IO 相比，进步的地方在于非阻塞 IO 模型中的 Worker 线程在 IO 操作没有 ready 的情况下不会被阻塞。只有当读或写的操作 ready 之后，Worker 线程才会执行任务，而不会无故的阻塞。

异步 IO 则是由操作系统来实现 IO 的读写操作，在数据 ready 之后，交由 Worker 线程来处理。

#### 系统 IO
IO 是一个和操作系统底层联系紧密的技术。对于像 Java 这样的带有虚拟机的语言，会提供一个统一的 IO 抽象。对于 C、C++ 这样的语言，IO 主要就取决于操作系统的支持。

非阻塞 IO 在 Linux 平台上通过 epoll 来支持，在 Windows 平台上通过 iocp 来提供支持。这两者都实现了通过少量的线程而处理多于这个数目的 IO channel 的目的。在 Linux kernel 的 2.6 版本中，引入了对异步 IO 的支持。

#### Java IO
Java 在 1.4 中引入了 NIO 的支持，在 7.0 (1.7) 中引入了 AIO 的支持。通常情况下，Java 开发者不应直接基于 JDK API 开发 IO 的功能，主要是相比操作系统本身提供的 API，JDK 的 API 已经提供了很高层次的抽象，但是对于应用开发来说仍显不足，而且 IO 开发技术要求非常高，需要掌握大量的系统和线程的知识，有大量的错误和特殊情况需要处理。而且 IO 功能通常是整个系统的基础，一旦出错影响将是严重的。所以通常建议开发人员使用 Netty、Mina 等 IO 框架来开发应用。Netty 相较 Mina 来说更多地被使用，Netty 最新版本（5.0）目前是基于 NIO 模型的。在 4.0 的一个早期版本中 Netty 曾使用了 AIO 模型，但是发现缺点大于优点，所以在随后的版本中又去掉了对 AIO 的支持。

### 序列化技术
序列化就是编程语言中的对象与二进制数据之间相互的转换。一个高性能的序列化技术对于一个好的远程调用解决方案来说是必须的。在序列化方面，有名的解决方案包括由 Google 创建的 Protocol Buffers、由 Facebook 创建的、现在由 Apache 社区维护的 Thrift、被 Hadoop 所使用的 Apache Arvo

### 框架介绍
* Apache Thrift
Thrift 是一个高性能、跨语言的 RPC 服务框架，适合用来实现内部服务的 RPC 调用。但是 Thrift 的序列化部分和整个框架结合紧密，并没有直接提供序列化和反序列化的接口，所以不容易和其它传输协议配合使用。

* Protocol Buffers
Protobuf 是一个高性能序列化解决方案，有完善的文档，可以和例如 HTTP 这样的协议搭配使用。

* Apache Avro
Apache Avro 是 Apache Hadoop 的一个子项目。它提供了两种序列化格式：JSON和二进制格式。JSON格式有良好的可读性，而二进制格式在性能上和 Protobuf 不相上下。

### 参考
* [序列化和反序列化](http://www.infoq.com/cn/articles/serialization-and-deserialization)

## 分布式系统之消息中间件
在分布式系统中，消息中间件的重要性越来越明显。消息中间件可以解耦模块、提供异步调用功能、消息持久化、消息削峰。这些功能对 Java EE 领域最著名的 JMS 的实现 ActiveMQ 现在已经无法满足互联网应用的性能需要了。但是另一方面，。所以随后出现的 RabbitMQ、LinkedIn 创建的 Apache Kafka 提供了更好的性能和更能满足大规模分布式应用的特性。

### Apache Kafka
Apache Kafka 充分利用了机械磁盘顺序读写速度快的特点，在接受消息之后同步地写入到磁盘中，保证数据可靠性的同时，也保证了非常快的速度。每个 Kafka 集群上都有多个 Topic，Topic 相当于一个 category，消费者可以订阅一个或多个 Topic。每个 Topic 由多个 Partition 组成。消息被顺序的添加到 Partition 中，每条消息有一个唯一的、有序的 ID，这个 ID 被称为 Offset。Consumer 需要维护自己消费到的消息的位置 (Offset)。

#### Queue 模式和 Topic 模式
传统消息队列服务中有队列模式和发布订阅模式两种模式，前者一条消息只会被一个消费者消费；后者一条消息会发布给所有的订阅这个 Topic 的消费者。在 Kafka 中，这两种模式是使用一种方式 ―― 消费者组来实现的。在同一个消费者组中的不同消费者不会受到相同的消息。如果想实现发布订阅模式，消费者必须处于不同的消费者组中。

## 分布式系统之虚拟化技术
### OpenStack

### Docker

## 高可用系统
### Pacemaker
基于 Linux 的高可用集群解决方案