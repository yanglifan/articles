# 分布式系统技术概要
## 分布式系统之配置管理
**关键字：**Apache Zookeeper、Paxos 算法、Etcd、Raft、Apache Curator

配置数据往往是一个应用中最重要的数据之一。在分布式应用中，配置数据要比单机应用多得多，诸如远程服务的相关信息、节点的状态信息、Master 节点等数据。而且因为分布式应用应该尽量避免单点故障，所以在分布式应用中，配置数据往往会有多份，因此便有了数据一致性的问题。有的场景，例如一个应用节点向配置服务器注册它所能提供的服务的相关信息，例如 IP 地址、端口、服务版本等。这样的操作相对不容易产生冲突。但有的场景，例如为整个集群选举一个 Master 节点，因为在同一时刻，会有多个普通节点去竞选成为 Master 节点，所以冲突在所难免。此时，一个可以高效解决数据一致性问题的算法便是非常必要的了。

在这一领域，Paxos 算法被提出来解决这个问题。在 Paxos 算法中，有三个角色：proposers、acceptors 和 learners。当需要有新决议产生的时候，proposer 会向超过半数的 acceptors 提出提议，提议包含一个一直增大的提议号。acceptors 会保证接受当前它所受到的提议号最大的提议，并向发起提议 proposer 返回接受或拒绝。当 proposer 发现有超过半数的 acceptors 接受提议之后，它便会向整个集群宣布提议通过，变为决议。learners 不会参加表决，只会接受决议。

Paxos 算法的语言表述看上去不难，但是其中的技术难点并不少。好在现在已经有了很多的解决方案，其中最为著名的便是 Apache Zookeeper。Zookeeper 不仅可以用来存储配置数据，还可以用来实现集群 Master 选举、分布式锁等场景。Apache Curator 是 Zookeeper 的客户端，可以简化对 Zookeeper 的使用，实现各式的场景。

### Apache Zookeeper
Zookeeper 是一个分布式的服务管理框架。Zookeeper 的典型的应用场景包括配置文件的管理、集群管理、分布式锁、Leader 选举、队列管理等。Zookeeper 可工作在集群模式下，`zoo.cfg` 中记录着集群中所有 Zookeeper 服务器的地址，每个服务器有自己唯一的 ID。同时，每个服务器在自己的 `dataDir` 目录下还要有一个 `myid` 文件，以标示自己的 ID。在 Zookeeper 中，数据以树状的结构存储，类似于 LDAP 数据库。

现在类似 Zookeeper 的项目还有 CoreOS 的 Etcd 等

## 分布式存储之文件系统
### 块存储与对象存储
块存储是将一块裸盘提供给客户使用，但是这块裸盘可能是来自一块物理硬盘，也有可能是多块，或是来自不同服务器上的硬盘。对象存储提供了更高级的接口，通过这些接口可以读写文件以及相关的元数据。其中的元数据包含了文件每一个块的存储信息。通过文件元数据，文件可以被并行地操作。

### 分布式文件系统的高可用
为了保证数据的安全，分布式文件系统通常会将文件复制为三份。这三份数据会位于不同的服务器上，对应要求更高的系统，比如公有云存储。其中的一份数据会放置在另一个机房中，以保证即便整个机房出现故障，整个文件系统仍是可用的。

### Ceph
Ceph 目前是 OpenStack 的一个组件，提供了块存储和对象存储的功能。

### GridFS
GridFS 是 MongoDB 的一部分。用来存储超过 BSON 大小限制（16MB）的文件。GridFS 将文件分成一个个部分，分开存储。

### FastDFS
FastDFS 是一个轻量的分布式文件系统，适合存储中小文件（对象存储）。FastDFS 的跟踪服务器不负责记录文件的元信息。文件的具体存储位置等信息包含在返回给用户的 File ID 中。

## 分布式存储之内存
> 内存是新的硬盘，硬盘是新的磁带 
> -- Jim Gray

### Hazelcast
Hazelcast 是一个面向 Java 的分布式内存解决方案，提供了丰富的功能特性。实现了诸如分布式 Java 集合类、分布式锁、分布式 ExecutorService 实现等等。但现实往往是残酷的，Hazelcast 在实际应用中存在大量的缺陷。详见 [“hazelcast的坑爹事”](http://blog.csdn.net/hengyunabc/article/details/18514563)

### GridGain

### Memcached
Memcached 是老牌的“分布式”缓存解决方案。分布式之所以加引号，是因为 Memcached 服务器端本身并不支持分布式，服务器端每个节点之间并不会相互通信。分布式的支持需要客户端来实现。早期的内存分布式是通过节点之间复制来实现的，但这种方式却限制了可伸缩性。这也是因为诸如 Terrecotta 这样的内存分布式解决方案没有成为主流的原因。

## 分布式存储之数据库
### 关系型数据库访问中间件/框架
在大规模的分布式应用中，单库或者简单的读写分离已经无法满足要求，因此必须对数据库进行水平和垂直的划分和分库分表。在对数据库进行分库分表之后，应用对数据库的访问便不再是一件简单的事情了。应用在进行一次数据库操作时，其所对应的数据库的地址和表名必须通过某种逻辑运算才能得到。例如，ID从1到1,000,000的User数据是数据库1的User_1表中，ID从1,000,001到2,000,000的User数据在数据库1的User_2表中，而其它的User数据又会在不同的数据库的不同的表中。同时，还要考虑主从数据库，读写分离的问题。这样的数据库使用方式会使数据操作变得极为复杂，也会增加数据迁移，增容扩容时的难度。

对于这样复杂的问题，靠应用自己解决显然是不合适的。所以各家分布式应用的使用大户――互联网厂商，都自己实现了相应的解决方案。这些解决方案可分为中间间方式和框架方式，前者作为数据库访问的代理，使得分布式的数据库对应用是透明的。后者作为一个框架嵌入到应用中，也能起到类似的作用。这两种方式各有优劣，分别适合不同的场合。

### NoSQL
大部分 NoSQL 虽然对分布式的支持是友好的，但这并不意味着使用这些 NoSQL 数据库就可以轻轻松松地实现一个集群。例如著名的 Key/Value 数据库 Redis。它 3.0 之前一直没有官方的集群方案，所以各个大规模使用 Redis 都需要自己实现分布式方案，例如 Twitter 的 Twemproxy、豌豆荚的 Codis 等等。

在实现数据的分布式解决方案的时候，有一个算法是最常被使用的 ―― 一致性哈希算法，这里只是简单提一下，不做进一步介绍。

## 分布式系统之远程调用
**关键字：** NIO、Netty、epoll、Thrift、Protobuf
分布式系统中，组件的相互调用必须通过远程调用来实现。REST API 和消息队列广义上也算是远程调用，但前者通常用作公开的 API 或者大型服务间的调用。对于服务内部之间的更加细粒度的、频繁的远程调用，REST API 就显得性能不足。这主要是因为协议方面的限制。消息队列则额外地起到了异步和削峰的作用。所以我们这里侧重说一下非 WebService 和消息队列的远程调用。

远程调用的本身有两个重要的技术点，一个是 IO 技术、一个是序列化技术。另外，当组件间的调用变成远程调用之后所引入的服务注册、发现、路由的问题，这个问题可以简称为服务的治理。

远程调用毫无疑问会比本地调用要复杂许多，所以如何提高远程调用的易用性也是在实际开发中使用远程调用是需要考虑的一个重要问题。

### IO
IO 可简单分为阻塞IO与非阻塞IO、同步IO与异步IO 四种模型。阻塞 IO 模型值得是 IO 操作会阻塞发起 IO 的进程或者线程；非阻塞 IO 的一个实现方式 Reactor 模型，即在线程模型上，分出分配 IO 任务的 Boss 线程和执行 IO 操作的 Worker 线程。非阻塞 IO 与 阻塞 IO 相比，进步的地方在于非阻塞 IO 模型中的 Worker 线程在 IO 操作没有 ready 的情况下不会被阻塞。只有当读或写的操作 ready 之后，Worker 线程才会执行任务，而不会无故的阻塞。

异步 IO 则是由操作系统来实现 IO 的读写操作，在数据 ready 之后，交由 Worker 线程来处理。

#### 系统 IO
IO 是一个和操作系统底层联系紧密的技术。对于像 Java 这样的带有虚拟机的语言，会提供一个统一的 IO 抽象。对于 C、C++ 这样的语言，IO 主要就取决于操作系统的支持。

非阻塞 IO 在 Linux 平台上通过 epoll 来支持，在 Windows 平台上通过 iocp 来提供支持。这两者都实现了通过少量的线程而处理多于这个数目的 IO channel 的目的。在 Linux kernel 的 2.6 版本中，引入了对异步 IO 的支持。

#### Java IO
Java 在 1.4 中引入了 NIO 的支持，在 7.0 (1.7) 中引入了 AIO 的支持。通常情况下，Java 开发者不应直接基于 JDK API 开发 IO 的功能，主要是相比操作系统本身提供的 API，JDK 的 API 已经提供了很高层次的抽象，但是对于应用开发来说仍显不足，而且 IO 开发技术要求非常高，需要掌握大量的系统和线程的知识，有大量的错误和特殊情况需要处理。而且 IO 功能通常是整个系统的基础，一旦出错影响将是严重的。所以通常建议开发人员使用 Netty、Mina 等 IO 框架来开发应用。Netty 相较 Mina 来说更多地被使用，Netty 最新版本（5.0）目前是基于 NIO 模型的。在 4.0 的一个早期版本中 Netty 曾使用了 AIO 模型，但是发现缺点大于优点，所以在随后的版本中又去掉了对 AIO 的支持。

### 序列化技术
序列化就是编程语言中的对象与二进制数据之间相互的转换。一个高性能的序列化技术对于一个好的远程调用解决方案来说是必须的。在序列化方面，有名的解决方案包括由 Google 创建的 Protocol Buffers、由 Facebook 创建的、现在由 Apache 社区维护的 Thrift、被 Hadoop 所使用的 Apache Arvo

### 框架介绍
* Apache Thrift
Thrift 是一个高性能、跨语言的 RPC 服务框架，适合用来实现内部服务的 RPC 调用。但是 Thrift 的序列化部分和整个框架结合紧密，并没有直接提供序列化和反序列化的接口，所以不容易和其它传输协议配合使用。

* Protocol Buffers
Protobuf 是一个高性能序列化解决方案，有完善的文档，可以和例如 HTTP 这样的协议搭配使用。

* Apache Avro
Apache Avro 是 Apache Hadoop 的一个子项目。它提供了两种序列化格式：JSON和二进制格式。JSON格式有良好的可读性，而二进制格式在性能上和 Protobuf 不相上下。

### 参考
* [序列化和反序列化](http://www.infoq.com/cn/articles/serialization-and-deserialization)

## 分布式系统之消息中间件
**关键字：**Kafka、RabbitMQ
在分布式系统中，消息中间件的重要性越来越明显。消息中间件可以解耦模块、提供异步调用功能、消息持久化、消息削峰。已有的如 Apache ActiveMQ 无法满足新的需要，于是出现了如 RabbitMQ、Apache Kafka 等新型的消息中间件产品。

### Apache Kafka
Apache Kafka 充分利用了机械磁盘顺序读写速度快的特点，在接受消息之后同步地写入到磁盘中，保证数据可靠性的同时，也保证了非常快的速度。每个 Kafka 集群上都有多个 Topic，Topic 相当于一个 category，消费者可以订阅一个或多个 Topic。每个 Topic 由多个 Partition 组成。消息被顺序的添加到 Partition 中，每条消息有一个唯一的、有序的 ID，这个 ID 被称为 Offset。Consumer 需要维护自己消费到的消息的位置 (Offset)。

Apache Kafka 不同于传统的消息中间件，它采用“拉”消息模式，而不是传统的“推”消息模式。即客户端需要主动从消息中间件获取消息，好处是客户端可以更好地控制请求量。

#### Queue 模式和 Topic 模式
传统消息队列服务中有队列模式和发布订阅模式两种模式，前者一条消息只会被一个消费者消费；后者一条消息会发布给所有的订阅这个 Topic 的消费者。在 Kafka 中，这两种模式是使用一种方式 ―― 消费者组来实现的。在同一个消费者组中的不同消费者不会受到相同的消息。如果想实现发布订阅模式，消费者必须处于不同的消费者组中。

### [RabbitMQ](https://www.rabbitmq.com/tutorials/tutorial-one-java.html)
RabbitMQ 是一个使用 Erlang 开发的 AMQP (Advanced Message Queue Protocol) 实现。现在 RabbitMQ 是由 VMware 旗下的 SpringSource 负责开发。AMQP 是一个语言无关的消息队列协议。在 RabbitMQ 中，有三个概念：Exchange、Queue 和 Route key。Exchange 用来标示生产者，Queue 用来标示消费者，而 Route key 用来关联这两者。RabbitMQ 中这种方式提供了更灵活的应用模式。

## 分布式系统之虚拟化技术
**关键字：**OpenStack、Docker、容器技术
虚拟化技术是提高硬件利用率的重要手段。虚拟化技术是实现云计算的重要技术。虚拟化技术的最底层是各种硬件的虚拟化，如 CPU 虚拟化、内存虚拟化、存储虚拟化、网络虚拟化等等。然后再基于这些技术，构建出各种虚拟机技术。然后各个厂商又基于虚拟机技术和其它虚拟化技术构建出 IaaS、PaaS 和 SaaS 等平台和软件产品。

### OpenStack
OpenStack 这个开源项目包含了一系列用于 IaaS 平台搭建的组件的合称。这些组件包含用于网络虚拟化的 Neutron、提供存储虚拟化的 Ceph 和 Swift、以及提供例如镜像管理、控制面板等功能的诸多组件。OpenStack 本身并不提供虚拟化技术，而是通过支持诸多现有的虚拟化技术，例如 KVM，并在此之上提供一系列构建 IaaS 解决方案的技术。OpenStack 中的组件可以灵活搭配使用，并且因为开源的原因，使用者可以对其进行自定义或二次开发。但是也是因为这个原因，任何厂商想要成功使用 OpenStack 必须有一个强大的技术团队做后盾。这也是目前 OpenStack 技术发展遇到的最大困难。

### Docker
严格说来 Docker 并不是一个虚拟化技术，但是因为 Docker 能够提供给使用者一种轻量化的虚拟机的使用体验，所以也将 Docker 列在这里。Docker 是一个容器技术，它通过 Linux 内核的支持，使不同的进程可以相互隔离并做到资源的限制，从而实现了部分的虚拟机资源隔离的需要。Docker 相比较虚拟机的优势在于轻量和系统资源使用效率接近于实体机。因为现在随着需求的发展和技术的进步，服务器端应用向着一种轻量化和越来越分布式的方向发展。虚拟机这样重量级的技术对于小而多的应用来说便不再合适，这也是 Docker 这样的容器技术近些年迅速发展并呈现火热状态的重要原因。

### SDN

## 分布式系统之负载均衡
### HAProxy
HAProxy 是一个高性能的 TCP 和 HTTP 反向代理代理和负载均衡服务器。可用反向代理和负载均衡还有 Nginx。Niginx 更偏向于 HTTP 协议。另外 Varnish 和 Squid 可以作为前端的代理，但是它们更偏重缓存功能

## 更上一层
### 服务编排：注册、发现和路由
**结合技术：**配置管理、远程调用等
有些类似早年的 JNDI。即一个应用去远程访问另外一个应用时，只需知道它所要访问的应用的名称、版本等信息，即可调用成功。不需要考虑它所要调用的应用的具体地址。

### 云操作系统
**结合技术：**虚拟机、容器技术、网络虚拟化、配置管理、消息队列
Apache Mesos、Google Berg、腾讯 Gaia、百度 Matrix