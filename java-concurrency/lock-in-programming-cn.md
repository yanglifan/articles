# 工作内存和主内存
JVM 的变量（指实例变量和类变量，不包括局部变量）是存放在 JVM 主内存中，当线程要操作某个变量时，JVM 会先将变量从主内存中读取，加载到线程的工作内存上，之后在进行执行的动作。JVM 线程不会直接操作主内存。这便是 Java 多线程中的可见性问题。

# Java 变量操作
read, load, use, assign, store, write
lock, unlock

# volatile
volatile 关键字可以保证工作内存中的变量在被赋值之后立即写入主内存，读取工作内存中的变量之前都会先从主内存中加载。这就好像是线程在直接操作主内存的变量。从而解决了可见性的问题。但是要注意 volatile 不能解决强一致性问题。

# 锁的目的
一致性
线程协调 wait, notify, notifyAll, await, signal

# synchronized
synchronized 块 优于 synchronized 方法
专用的 monitor 优于 this
monitor 应该有清晰的名称，表明锁的目的

AutowiredFieldElement.inject

# 线程状态与锁的关系
显式锁会导致线程处于 WAITING 状态，`synchronized` 会导致线程进入 BLOCKED 状态。

# 缩小锁的范围
在实际应用中，我们要尽量缩写锁的范围。在共享变量的一致性对我们十分重要的情况下，用尽可能小的锁的范围去保护共享变量的一致性。
我们以 `DeviceManager.handleVC2ServerProvision` 为例

# 分段锁
ConcurrentHashMap 就采用了分段锁的思想。如果我们的功能需要保证一组可由一个 key 识别的数据的一致性，那可以通过对这个key做hash，再取余数，通过余数获取一个小范围的锁，来保证这一组数据的一致性。

# 乐观锁
前面介绍的锁都可算作悲观锁，即排他锁。还有一种保障数据一致的方式是乐观锁。Java 从 5.0 开始通过 CAS (Compare and swap，多数 CPU 包含此指令)的方式实现乐观锁方式。即和期望值比较成功之后再赋值。CAS 也被成为无锁式的并发。Java 5 引入的例如 `ReentrantLock` 等大量的工具类都是基于此方式。

此外，`ConcurrentHashMap` 虽然主要采用分段锁的思想提高并发性能，但是也大量采用 CAS 以提高性能。

在数据库领域，Hibernate 等框架通过引入额外的字段来支持乐观锁。NoSQL 中的 Redis 也支持 check-then-set 式的乐观锁操作方式。

# 分布式锁
在一个单机应用中，我们可以通过编程语言层面的锁去同步线程，保证数据的强一致性，或称保证操作的原子性。但是对于分布式应用来说，编程语言层面的锁无法保证应用数据的强一致性。如果需要，必须考虑基于例如 Apache Zookeeper 这样的应用实现分布式锁。

# 一致性：强一致性、最终一致性和分布式一致性
强一致性在多数情况下，即便是单机应用，往往也是难以实现的。分布式锁虽然能实现分布式系统的强一致性，但是代价过大，在多数的操作中不会使用。所以，现在的服务器端应用多数保证的是最终一致性和局部的强一致性。在分布式系统中，还有一个更麻烦的分布式一致性问题。解决这类问题就需要例如 PAXOS 这样的分布式一致性算法解决。

# 分别用synchronized和lock实现生产者消费者

# 如何解决哲学家问题